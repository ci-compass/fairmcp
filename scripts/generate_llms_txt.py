#!/usr/bin/env python
"""
Generate llms.txt file that indexes all CommonMark documents in the repository.
This provides an index for LLMs to access the documentation.
"""

import os
import glob
from pathlib import Path
import datetime

def main():
    # Base directory
    base_dir = Path(__file__).parent.parent
    # Output file (llms.txt in the repository root)
    output_file = base_dir / "llms.txt"
    
    # Find CommonMark files generated by Quarto
    cm_files = []
    
    # Look for *-commonmark.md files in _site directory
    for ext in ["*-commonmark.md"]:
        cm_files.extend([
            f for f in glob.glob(str(base_dir / "_site" / "**" / ext), recursive=True)
        ])
    
    # Look for regular .md files in _site directory (some pages don't use -commonmark suffix)
    for ext in ["*.md"]:
        md_files = [
            f for f in glob.glob(str(base_dir / "_site" / "**" / ext), recursive=True)
            if not f.endswith("-commonmark.md")  # Skip files we already found
        ]
        cm_files.extend(md_files)
    
    # Sort the files
    cm_files.sort()
    
    # Current date
    today = datetime.datetime.now().strftime("%Y-%m-%d")
    
    # Generate content following the llmstxt format
    content = [
        "# FAIR MCP Documentation",
        "",
        f"FAIRMCP Team",
        f"{today}",
        "",
        "> FAIRMCP provides a Model Context Protocol (MCP) server for FAIR documentation. This repository combines FAIR principles (Findable, Accessible, Interoperable, Reusable) documentation with a Model Context Protocol (MCP) server implementation.",
        "",
        "The following markdown documents are available in this repository for LLMs to reference.",
        "",
        "## Core Documentation",
        ""
    ]
    
    # Group files by directory
    file_groups = {}
    for file_path in cm_files:
        # Convert to relative web path
        rel_path = os.path.relpath(file_path, base_dir / "_site")
        if rel_path.endswith("-commonmark.md"):
            # Replace -commonmark.md with .md for consistency
            rel_path = rel_path.replace("-commonmark.md", ".md")
        
        dir_name = os.path.dirname(rel_path)
        if not dir_name:
            dir_name = "Root"
        
        if dir_name not in file_groups:
            file_groups[dir_name] = []
        
        # Get the file title from content
        try:
            with open(file_path, 'r') as f:
                first_lines = []
                for _ in range(20):  # Read first 20 lines to find title
                    line = next(f, None)
                    if line is None:
                        break
                    first_lines.append(line)
                
                title = None
                # First try to find a H1 header (# Title)
                for line in first_lines:
                    if line.startswith('# '):
                        title = line[2:].strip()
                        break
                
                # If no H1, try to find a title in YAML front matter
                if not title:
                    in_yaml = False
                    for line in first_lines:
                        if line.strip() == '---':
                            in_yaml = not in_yaml
                            continue
                        if in_yaml and 'title:' in line:
                            title = line.split('title:', 1)[1].strip().strip('"\'')
                            break
        except Exception:
            title = None
            
        if not title:
            # Use filename without extension as title
            title = os.path.basename(rel_path).rsplit('.', 1)[0]
        
        file_groups[dir_name].append((title, rel_path))
    
    # Add file groups to content
    # First add files from root and key directories
    priority_dirs = ["Root", "docs/principles", "docs/implementations"]
    
    for dir_name in priority_dirs:
        if dir_name in file_groups and file_groups[dir_name]:
            if dir_name != "Root":
                dir_title = dir_name.split('/')[-1].capitalize()
                content.append(f"## {dir_title}")
                content.append("")
            
            for title, rel_path in file_groups[dir_name]:
                content.append(f"- [{title}]({rel_path}): {get_file_description(rel_path)}")
            
            content.append("")
            # Remove processed directory
            file_groups.pop(dir_name)
    
    # Add remaining directories
    content.append("## Optional")
    content.append("")
    
    for dir_name in sorted(file_groups.keys()):
        if file_groups[dir_name]:
            for title, rel_path in file_groups[dir_name]:
                content.append(f"- [{title}]({rel_path})")
    
    # Write to file
    with open(output_file, 'w') as f:
        f.write('\n'.join(content))
    
    print(f"Generated llms.txt at {output_file}")

def get_file_description(rel_path):
    """Generate a short description based on the file path"""
    if "principles" in rel_path:
        return "FAIR principles documentation"
    elif "implementations" in rel_path:
        return "Implementation guide"
    elif "index" in rel_path:
        return "Main page"
    elif "CLAUDE" in rel_path:
        return "Project guidelines"
    else:
        return ""

if __name__ == "__main__":
    main()